<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="iOS,React Native," />










<meta name="description" content="React Native源码分析原理（一）(基于0.48版本) React Native源码分析原理（二）(基于0.48版本)  上一篇文章大家如果仔细阅读揣摩对RN有了一个初步的认识了，接下来将基于上一篇文章的这种初步认识然我们详细了解一下RN的启动过程 启动过程[RCTRootView initWithBundleURL:…][RCTBridge initWithBundleURL:…][R">
<meta name="keywords" content="iOS,React Native">
<meta property="og:type" content="article">
<meta property="og:title" content="React Native源码分析原理（二）(基于0.48版本)">
<meta property="og:url" content="http://yoursite.com/2017/10/14/React Native源码分析原理（二）(基于0.48版本)/index.html">
<meta property="og:site_name" content="FlyOceanFish&#39; Blog">
<meta property="og:description" content="React Native源码分析原理（一）(基于0.48版本) React Native源码分析原理（二）(基于0.48版本)  上一篇文章大家如果仔细阅读揣摩对RN有了一个初步的认识了，接下来将基于上一篇文章的这种初步认识然我们详细了解一下RN的启动过程 启动过程[RCTRootView initWithBundleURL:…][RCTBridge initWithBundleURL:…][R">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-01-22T05:56:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Native源码分析原理（二）(基于0.48版本)">
<meta name="twitter:description" content="React Native源码分析原理（一）(基于0.48版本) React Native源码分析原理（二）(基于0.48版本)  上一篇文章大家如果仔细阅读揣摩对RN有了一个初步的认识了，接下来将基于上一篇文章的这种初步认识然我们详细了解一下RN的启动过程 启动过程[RCTRootView initWithBundleURL:…][RCTBridge initWithBundleURL:…][R">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/14/React Native源码分析原理（二）(基于0.48版本)/"/>





  <title>React Native源码分析原理（二）(基于0.48版本) | FlyOceanFish' Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8f73d05f1a471433ed938c462af80741";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/FlyOceanFish"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">FlyOceanFish' Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">You Believe,You Can</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/14/React Native源码分析原理（二）(基于0.48版本)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FlyOceanFish">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FlyOceanFish' Blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">React Native源码分析原理（二）(基于0.48版本)</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-14T13:27:01+08:00">
                2017-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React-Native/" itemprop="url" rel="index">
                    <span itemprop="name">React Native</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li><a href="http://www.jianshu.com/p/8324b379c020" target="_blank" rel="external">React Native源码分析原理（一）(基于0.48版本)</a></li>
<li><a href="http://www.jianshu.com/p/0688b24950f4" target="_blank" rel="external">React Native源码分析原理（二）(基于0.48版本)</a></li>
</ul>
<p>上一篇文章大家如果仔细阅读揣摩对RN有了一个初步的认识了，接下来将基于上一篇文章的这种初步认识然我们详细了解一下RN的启动过程</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>[RCTRootView initWithBundleURL:…]<br>[RCTBridge initWithBundleURL:…]<br>[RCTBridge setUp]<br>初始化batchedBridge<br>[RCTCxxBridge start]<br>开启一个线程jsThread用于js<br>[RCTCxxBridge _initModulesWithDispatchGroup]<br>初始化JSCExecutorFactory, 用于执行js代码以及处理回调 JSCExecutor::JSCExecutor()<br>JSCExecutor::initOnJSVMThread()<br>installGlobalProxy -&gt; nativeModuleProxy<br>RCTJavaScriptLoader -&gt; 加载js代码<br>[RCTCxxBridge executeSourceCode]<br>[RCTRootView initWithBridge:…]<br>[RCTRootView bundleFinishedLoading]<br>初始化RCTRootContentView<br>[RCTRootView runApplication]//是Native调用js的一个完美例子。本质调用了AppRegistry的runApplication方法<br>我们初始化RN工程一般都是如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index.ios&quot; fallbackResource:nil];</div><div class="line"></div><div class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</div><div class="line">                                                    moduleName:@&quot;AwesomeProject&quot;</div><div class="line">                                             initialProperties:nil</div><div class="line">                                                 launchOptions:launchOptions];</div></pre></td></tr></table></figure></p>
<p>1、 获取到app的js入口文件的NSURL<br>2 、初始化RCTRootView, 传递的参数moduleName:@”AwesomeProject”是我们在入口的js文件中注册的, initialProperties:nil, 将作为js中的跟view的props, 可以用来传递需要的初始数据</p>
<p>进入RCTRootView初始化中，其实很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:bundleURL</div><div class="line">                                          moduleProvider:nil</div><div class="line">                                           launchOptions:launchOptions];</div><div class="line"></div><div class="line">return [self initWithBridge:bridge moduleName:moduleName initialProperties:initialProperties];</div></pre></td></tr></table></figure></p>
<p>就实例化了一个RCTBridge，这个RCTBridge的实例其实就是一个外壳而已，接下来我们看看内部，为啥是一个外壳。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self setUp];</div></pre></td></tr></table></figure></p>
<p>内部中这个方法就是关键，这个方法里边实例化了一个真正的Bridge，即<code>RCTCxxBridge</code>或<code>RCTBatchedBridge</code>，所以说一开始实例化的Bridge只是一个壳子而已。为什么会出现两个不同的Bridge呢？主要是0.44之前的都是用的<code>RCTBatchedBridge</code>，之后RN用的是<code>RCTCxxBridge</code>，根据它的官方资料<code>RCTCxxBridge</code>会慢慢取代<code>RCTBatchedBridge</code>。(<code>RCTCxxBridge</code>有个问题就是依赖了4个包，而且这4个包被墙了具体可以看<a href="http://www.jianshu.com/p/1927785a3ba7" target="_blank" rel="external">将RN工程嵌入到现有原生iOS应用</a>)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.batchedBridge = [[bridgeClass alloc] initWithParentBridge:self];</div><div class="line">[self.batchedBridge start];</div></pre></td></tr></table></figure></p>
<p>首先是bridgeClass的获取，具体代码是优先加载<code>RCTCxxBridge</code>，如果获取不到的话，其次加载<code>RCTBatchedBridge</code>。本次分析是基于0.48并且工程初始化是使用了<code>RCTCxxBridge</code>，所以下边只要提到Bridge说的就是<code>RCTCxxBridge</code>。</p>
<p>start是一个非常有料的方法。就像之前说的Bridge其实就是实现了一个调度管理的作用，那调度管理什么呢？所有需要调度管理的前提环境和类全部都是在start方法进行了初始化。</p>
<p>1、  首先做的是实例化了一个js线程，我们之前所说的js thread就是它，用来执行js代码的线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Set up the JS thread early</div><div class="line">_jsThread = [[NSThread alloc] initWithTarget:self</div><div class="line">                                    selector:@selector(runJSRunLoop)</div><div class="line">                                      object:nil];</div><div class="line">_jsThread.name = RCTJSThreadName;</div><div class="line">_jsThread.qualityOfService = NSOperationQualityOfServiceUserInteractive;</div><div class="line">[_jsThread start];</div></pre></td></tr></table></figure></p>
<p>这个线程执行的方法是<code>runJSRunLoop</code>通过名字大家也能猜出一个大概吧。其实就是启动了线程的runloop，保证了_jsThread能够一直运行。</p>
<p>2、创建了一个group，用来初始化Birdge。接下来就开始加载我们本地所有的已经实现了RCTBridgeModule协议的modules<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> dispatch_group_t prepareBridge = dispatch_group_create();</div><div class="line">// Initialize all native modules that cannot be loaded lazily</div><div class="line">[self _initModulesWithDispatchGroup:prepareBridge];</div></pre></td></tr></table></figure></p>
<p>3、让我们看看initModulesWithDispatchGroup内部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">for (Class moduleClass in RCTGetModuleClasses()) &#123;</div><div class="line">   NSString *moduleName = RCTBridgeModuleNameForClass(moduleClass);</div><div class="line"></div><div class="line">   // Don&apos;t initialize the old executor in the new bridge.</div><div class="line">   // TODO mhorowitz #10487027: after D3175632 lands, we won&apos;t need</div><div class="line">   // this, because it won&apos;t be eagerly initialized.</div><div class="line">   if ([moduleName isEqual:@&quot;RCTJSCExecutor&quot;]) &#123;</div><div class="line">     continue;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Check for module name collisions</div><div class="line">   RCTModuleData *moduleData = moduleDataByName[moduleName];</div><div class="line">   if (moduleData) &#123;</div><div class="line">     if (moduleData.hasInstance) &#123;</div><div class="line">       // Existing module was preregistered, so it takes precedence</div><div class="line">       continue;</div><div class="line">     &#125; else if ([moduleClass new] == nil) &#123;</div><div class="line">       // The new module returned nil from init, so use the old module</div><div class="line">       continue;</div><div class="line">     &#125; else if ([moduleData.moduleClass new] != nil) &#123;</div><div class="line">       // Both modules were non-nil, so it&apos;s unclear which should take precedence</div><div class="line">       RCTLogError(@&quot;Attempted to register RCTBridgeModule class %@ for the &quot;</div><div class="line">                   &quot;name &apos;%@&apos;, but name was already registered by class %@&quot;,</div><div class="line">                   moduleClass, moduleName, moduleData.moduleClass);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   // Instantiate moduleData</div><div class="line">   // TODO #13258411: can we defer this until config generation?</div><div class="line">   moduleData = [[RCTModuleData alloc] initWithModuleClass:moduleClass</div><div class="line">                                                    bridge:self];</div><div class="line">   moduleDataByName[moduleName] = moduleData;</div><div class="line">   [moduleClassesByID addObject:moduleClass];</div><div class="line">   [moduleDataByID addObject:moduleData];</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>主要是循环遍历用2个数组分别存储了所有的class和RCTModuleData(存储着我们class所有的信息包括class名称、所有的方法、等一些有效的信息和一个instance。还有一个Dictionary key是class，value是moudleData。这个就是通过class名称去取moduleData用的。</p>
<p>这个方法中有一个很重要的方法<code>RCTGetModuleClasses()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void RCTRegisterModule(Class);</div><div class="line">void RCTRegisterModule(Class moduleClass)</div><div class="line">&#123;</div><div class="line">  static dispatch_once_t onceToken;</div><div class="line">  dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">    RCTModuleClasses = [NSMutableArray new];</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  RCTAssert([moduleClass conformsToProtocol:@protocol(RCTBridgeModule)],</div><div class="line">            @&quot;%@ does not conform to the RCTBridgeModule protocol&quot;,</div><div class="line">            moduleClass);</div><div class="line"></div><div class="line">  // Register module</div><div class="line">  [RCTModuleClasses addObject:moduleClass];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是我们一直说的必须要实现了RCTBridgeModule这个协议，如果实现其实会直接报错的。这个加载是通过<code>RCT_EXPORT_MODULE()</code>宏来实现的，宏是通过运行时<code>+load()</code>方法在我们应用启动的时候其实已经将所有的module加入到了数组之中。</p>
<p>4 、以上终于完成了Modules信息的保存, 接着会进行JSExecutorFactory的初始化和相关的设置, JSExecutorFactory内部会持有一个JSCExecutor 所有与JS的通信，一定都通过JSCExecutor来进行, 所以需要重点关注, 它的构造函数中调用了initOnJSVMThread(), 里面进行了很多的JS上下文的准备, 创建JSClass, 全局的context, 以及添加全局的回调.注意在这个里面使用到的JSC<em>JSXXX的宏的作用, 实际上是会转换为调用苹果的JavaScriptCore对应的方法(去掉JSC</em>), 同时还要留意JSCExecutor构造函数中为js的上下文中设置了一个Proxy, nativeModuleProxy.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void JSCExecutor::initOnJSVMThread()</div><div class="line">  // 在js的上下文中注册全局的闭包回调 , 这两个是我们需要重点关注的回调.</div><div class="line">  nativeFlushQueueImmediate</div><div class="line">  nativeCallSyncHook</div><div class="line"></div><div class="line">    installNativeHook&lt;&amp;JSCExecutor::nativeFlushQueueImmediate&gt;(&quot;nativeFlushQueueImmediate&quot;);</div><div class="line">    // 这一个注册的回调, 可以用于在js中直接调用oc, 注意, 在rn中js调用oc一般都是由oc发起的,</div><div class="line">    // 这就像我们的界面一般是有用户的操作才会触发系统调用, rn中类似的,</div><div class="line">    // 当oc调了js后, 在对应的js回调中才会实现调用oc的逻辑</div><div class="line"></div><div class="line"> // 在react native MessageQueue.js中的源码中可以找到 这样一段代码,</div><div class="line"> // 就是当oc没有及时的在消息队列中调js的时候, 大于5ms后js就会调用这个回调, 主动调用oc</div><div class="line"></div><div class="line">   MIN_TIME_BETWEEN_FLUSHES_MS = 5ms;</div><div class="line">      if (global.nativeFlushQueueImmediate &amp;&amp;</div><div class="line">        (now - this._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS ||</div><div class="line">         this._inCall === 0)) &#123;</div><div class="line">      var queue = this._queue;</div><div class="line">      this._queue = [[], [], [], this._callID];</div><div class="line">      this._lastFlush = now;</div><div class="line">      global.nativeFlushQueueImmediate(queue);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 这个回调是用来调用查找native中对应的方法相关信息的</div><div class="line"></div><div class="line">installNativeHook&lt;&amp;JSCExecutor::nativeCallSyncHook&gt;(&quot;nativeCallSyncHook&quot;);</div><div class="line">在react native的 NativeModules.js中有相关的调用来获取native方法的相关信息</div><div class="line">function genMethod(moduleID: number, methodID: number, type: MethodType) &#123;</div><div class="line">//...</div><div class="line">    return global.nativeCallSyncHook(moduleID, methodID, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为js的上下设置 nativeModuleProxy, 这一个属性很重要, js端用来获取所有注册的nativeModule. 在js中我们需要引入native端的时候回写这样的类似代码 var {NativeModules} from ‘react-native’, 实际上就是获取到我们这里设置的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">JSCExecutor::JSCExecutor()</div><div class="line">  &#123;</div><div class="line">  // 这个函数在js的全局上下文中设置了`nativeModuleProxy`,</div><div class="line">// 使得在js端可以获取到, 同时注意这个函数的第三个参数中</div><div class="line">// 还包装了一个方法用于调用, 里面涉及到JSCNativeModules这个类,</div><div class="line">// 就是获取NativeModule的操作, 后面分析</div><div class="line">    installGlobalProxy(m_context, &quot;nativeModuleProxy&quot;,</div><div class="line">                       exceptionWrapMethod&lt;&amp;JSCExecutor::getNativeModule&gt;());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">在react-native 的NativeModules.js底部有这样的代码, 就直接调用了上面在native端设置的全局属性了</div><div class="line"></div><div class="line">let NativeModules : &#123;[moduleName: string]: Object&#125; = &#123;&#125;;</div><div class="line">if (global.nativeModuleProxy) &#123;</div><div class="line">  NativeModules = global.nativeModuleProxy;</div><div class="line">&#125;</div><div class="line">module.exports = NativeModules;</div></pre></td></tr></table></figure></p>
<p>那么js中是怎么获取到我们之前在native端已经生成好的’配置表’信息的呢? 这个问题需要我们重点关注下, 在之前的react-native版本中, 是通过native端直接在js的上下文中注入这样一个__fbBatchedBridgeConfig配置表,<br>传过去一个json(remoteModuleConfig). 现在的版本中改了一些. 还是上面这段代码. 在如下的调用栈中,我们只需要关注最后一个函数.</p>
<p>JSCExecutor::getNativeModule()<br>JSCNativeModules::getModule()<br>JSCNativeModules::createModule()<br>ModuleRegistry::getConfig()<br>RCTNativeModule::getMethods()<br>NSStringFromSelector(selector) hasPrefix:@”rct_export”(初始化RCTModuleMethod信息)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">folly::Optional&lt;Object&gt; JSCNativeModules::createModule(const std::string&amp; name, JSContextRef context) &#123;</div><div class="line">  if (!m_genNativeModuleJS) &#123;</div><div class="line">// 获取js中contenxt中的global</div><div class="line">    auto global = Object::getGlobalObject(context);  </div><div class="line">// 获取 global中的__fbGenNativeModule对象</div><div class="line">    m_genNativeModuleJS = global.getProperty(&quot;__fbGenNativeModule&quot;).asObject();</div><div class="line">    m_genNativeModuleJS-&gt;makeProtected();</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> // 这个方法最终会调到 RCTNativeModule::getMethods()中,</div><div class="line"> // 取得之前使用宏暴露的所有的方法  -&gt; 前缀是 &quot;__rct_export__&quot;</div><div class="line"> auto result = m_moduleRegistry-&gt;getConfig(name);</div><div class="line"></div><div class="line"></div><div class="line">  if (!result.hasValue()) &#123;</div><div class="line">    return nullptr;</div><div class="line">  &#125;</div><div class="line">// 调用 js中的__fbGenNativeModule方法, 并且传递过去native端的配置表, 用于端js处理</div><div class="line">  Value moduleInfo = m_genNativeModuleJS-&gt;callAsFunction(&#123;</div><div class="line">    Value::fromDynamic(context, result-&gt;config),</div><div class="line">    Value::makeNumber(context, result-&gt;index)</div><div class="line">  &#125;);</div><div class="line">  return moduleInfo.asObject().getProperty(&quot;module&quot;).asObject();</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 下面是对应的js中的处理, NativeModules.js</div><div class="line">// 暴露一个全局的属性给native(就是上面我们调用的js中的方法, 触发了后面的js后取到native端的配置表, 并且保存)</div><div class="line">// export this method as a global so we can call it from native</div><div class="line">global.__fbGenNativeModule = genModule;</div><div class="line"></div><div class="line">function genModule(...) &#123;</div><div class="line">  // 获取到native端调用时传递过来的配置信息</div><div class="line">  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;</div><div class="line">  const module = &#123;&#125;;</div><div class="line">  // 遍历 所有的native的方法列表, 获取所有native的方法的详细信息</div><div class="line">  methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123;</div><div class="line">    module[methodName] = genMethod(moduleID, methodID, methodType);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;</div><div class="line">function genMethod(...) &#123;</div><div class="line">  /// ...</div><div class="line">  // 调用之前native端在js中注入的回调, 获取native中的所有方法的详细信息</div><div class="line">  return global.nativeCallSyncHook(moduleID, methodID, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、 使用dispatch_group方式初始化Instance(执行代码需要), 和加载js代码RCTJavaScriptLoader,这个类比较单纯，就是用来加载js代码的，没有其他用处<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSData *sourceCode = [RCTJavaScriptLoader attemptSynchronousLoadOfBundleAtURL:self.bundleURL</div><div class="line">                                                                 runtimeBCVersion:bcVersion</div><div class="line">                                                                     sourceLength:NULL</div><div class="line">                                                                            error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>6、 modules and source code都已经准备好了, 在notify中JSCExecutor专属的Thread内执行jsbundle代码执行js代码. 执行完毕后会将_displayLink添加到runloop(注意是在jsThread所在的runloop)中, 开始运行。</p>
<p>[RCTCxxBridge executeSourceCode: ]<br>[RCTCxxBridge enqueueApplicationScript:]<br>void Instance::loadScriptFromString()<br>void NativeToJsBridge::loadApplication()<br>void JSCExecutor::loadApplicationScript()<br>void JSCExecutor::flush()<br>void JSCExecutor::bindBridge()<br>上面的调用栈中我们主要关注后面几个函数</p>
<p><code>void JSCExecutor::loadApplicationScript()</code>, 在这个函数中注意下面两行代码, 注意, RN中有个很明显的问题就是, 首次进入RN模块的时候, 加载的很慢, 会有几秒的加载时间, 其实就是在这个函数中加载jsBundle造成的, 如果要优化加载的时间, 以及不同模块页面切换流畅, 就需要对jsBundle文件进行精简, 缓存等操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 执行js代码, 加载jsBundle</div><div class="line">evaluateScript(m_context, jsScript, jsSourceURL);</div><div class="line">// 在加载完jsbundle后主动调用一次, 为js的上下文环境添加必要的全局属性和回调</div><div class="line">flush();</div></pre></td></tr></table></figure></p>
<p>void JSCExecutor::bindBridge()保存js的上下文环境中必要的全局属性和回调, 这些在 react native的 MessageQueue.js中定义的调用方法, 当native需要调用js的方法的时候, 需要通过调用这些js方法, 在这些方法中, js端会根据传递的信息查找到在js中需要调用的方法.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">    auto global = Object::getGlobalObject(m_context);</div><div class="line">    auto batchedBridgeValue = global.getProperty(&quot;__fbBatchedBridge&quot;);</div><div class="line">// 这些是在MessageQueue.js中定义的调用方法</div><div class="line">    auto batchedBridge = batchedBridgeValue.asObject();</div><div class="line">    m_callFunctionReturnFlushedQueueJS = batchedBridge.getProperty(&quot;callFunctionReturnFlushedQueue&quot;).asObject();</div><div class="line">    m_invokeCallbackAndReturnFlushedQueueJS = batchedBridge.getProperty(&quot;invokeCallbackAndReturnFlushedQueue&quot;).asObject();</div><div class="line">    m_flushedQueueJS = batchedBridge.getProperty(&quot;flushedQueue&quot;).asObject();</div><div class="line">    m_callFunctionReturnResultAndFlushedQueueJS = batchedBridge.getProperty(&quot;callFunctionReturnResultAndFlushedQueue&quot;).asObject();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>7 、上面的工作完成之后, 初始化bridge的工作就完成了, jsBundle已经加载完成, oc端的’配置表’也已经处理好, 并且成功已经传递给js端, js的上下文配置已经准备好, 下面就是开始执行我们的js代码了, React就会开始计算好所有的布局信息, 以及Component层级关系等, 等待native端完成对应的真正的页面渲染和布局. 回到RCTRootView的初始化方法中, 注意在[RCTRootView initWithBridge:…]的初始化方法中, 注册了几个js执行情况的通知, 我们重点关注js执行完毕后的通知RCTJavaScriptDidLoadNotification<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithBundleURL:(NSURL *)bundleURL</div><div class="line">                       moduleName:(NSString *)moduleName</div><div class="line">                initialProperties:(NSDictionary *)initialProperties</div><div class="line">                    launchOptions:(NSDictionary *)launchOptions</div><div class="line">&#123;</div><div class="line">  RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:bundleURL</div><div class="line">                                            moduleProvider:nil</div><div class="line">                                             launchOptions:launchOptions];</div><div class="line">// 上面完成了bridge的初始化工作 , 下面开始完成rootView的初始化</div><div class="line">  return [self initWithBridge:bridge moduleName:moduleName initialProperties:initialProperties];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是js执行完毕后的通知RCTJavaScriptDidLoadNotification中的一系列的处理</p>
<p>[RCTRootView javaScriptDidLoad]<br>[RCTRootView bundleFinishedLoading]<br>RCTRootContentView (创建contentView)<br>[RCTRootView runApplication]<br>在创建RCTRootContentView的时候, 注意有个参数是reactTag, 这个属性很重要, 每一个reactTag都应该是唯一的, 从1开始, 每次递增10. RCTRootContentView初始化时, 还需要在RCTUIManager中通过reactTag去注册, 从而由RCTUIManager来统一管理所有的js端使用Component对应的每个原生view(_viewRegistry[tag]表), 有了这个, 我们就可以很方便的在其他地方通过reactTag获取到我们的Component所在的rootView.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    /**</div><div class="line">     * Every root view that is created must have a unique react tag.</div><div class="line">     * Numbering of these tags goes from 1, 11, 21, 31, etc</div><div class="line">     *</div><div class="line">     * NOTE: Since the bridge persists, the RootViews might be reused, so the</div><div class="line">     * react tag must be re-assigned every time a new UIManager is created.</div><div class="line">     */</div><div class="line"></div><div class="line">- (NSNumber *)allocateRootTag</div><div class="line">&#123;</div><div class="line">  NSNumber *rootTag = objc_getAssociatedObject(self, _cmd) ?: @1;</div><div class="line">  objc_setAssociatedObject(self, _cmd, @(rootTag.integerValue + 10), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">  return rootTag;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后才是[RCTRootView runApplication], 这里就会调用js里面AppRegistry对应的方法runApplication了, 在AppRegistry.js中有下面的一段注释, 已经解释得很清楚了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * `AppRegistry` is the JS entry point to running all React Native apps.  App</div><div class="line"> * root components should register themselves with</div><div class="line"> * `AppRegistry.registerComponent`, then the native system can load the bundle</div><div class="line"> * for the app and then actually run the app when it&apos;s ready by invoking</div><div class="line"> * `AppRegistry.runApplication`.</div><div class="line"> *</div><div class="line"> * To &quot;stop&quot; an application when a view should be destroyed, call</div><div class="line"> * `AppRegistry.unmountApplicationComponentAtRootTag` with the tag that was</div><div class="line"> * passed into `runApplication`. These should always be used as a pair.</div><div class="line"> *</div><div class="line"> * `AppRegistry` should be `require`d early in the `require` sequence to make</div><div class="line"> * sure the JS execution environment is setup before other modules are</div><div class="line"> * `require`d.</div><div class="line"> */</div><div class="line"></div><div class="line">- (void)runApplication:(RCTBridge *)bridge</div><div class="line">&#123;</div><div class="line">  NSString *moduleName = _moduleName ?: @&quot;&quot;;</div><div class="line">  NSDictionary *appParameters = @&#123;</div><div class="line">    @&quot;rootTag&quot;: _contentView.reactTag,</div><div class="line">    @&quot;initialProps&quot;: _appProperties ?: @&#123;&#125;,</div><div class="line">  &#125;;</div><div class="line">// 调用AppRegistry.js中的runApplication开始运行</div><div class="line">  RCTLogInfo(@&quot;Running application %@ (%@)&quot;, moduleName, appParameters);</div><div class="line">  [bridge enqueueJSCall:@&quot;AppRegistry&quot;</div><div class="line">                 method:@&quot;runApplication&quot;</div><div class="line">                   args:@[moduleName, appParameters]</div><div class="line">             completion:NULL];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>8、 因为执行js代码的时候, js端会计算好每个view的布局, 属性等信息, 然后通过调用native的系统方法来完成, 页面的渲染, 页面的布局. 这个过程中就涉及到了js 和native的互调通信了. 这个过程分为两个部分.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
            <a href="/tags/React-Native/" rel="tag"># React Native</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/14/React Native源码分析原理（一）(基于0.48版本)/" rel="next" title="React Native源码分析原理（一）(基于0.48版本)">
                <i class="fa fa-chevron-left"></i> React Native源码分析原理（一）(基于0.48版本)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/14/在mac上快速搭建Android、iOS自动打包环境(一)/" rel="prev" title="在mac上快速搭建Android、iOS自动打包环境(一)">
                在mac上快速搭建Android、iOS自动打包环境(一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="vcomments"></div>
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="FlyOceanFish" />
            
              <p class="site-author-name" itemprop="name">FlyOceanFish</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动过程"><span class="nav-number">1.</span> <span class="nav-text">启动过程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FlyOceanFish</span>

  
</div>

<!--
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>

-->


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  










  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine@1.1.6/dist/Valine.min.js"></script>
  <script type="text/javascript">
    new Valine({
        av: AV,
        el: '#comments' ,
        verify: false,
        notify: false,
        app_id: 'BUyek27xhBJW608unzBEyhWI-gzGzoHsz',
        app_key: 'lT2NUWTMwPfNYl6xMQUtUxDv',
        placeholder: '请输入评论'
    });
  </script>



  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.3"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.3"></script>


  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
